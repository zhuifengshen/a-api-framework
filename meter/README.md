# 演进式接口自动化测试框架

## 从零搭建接口自动化测试脚手架
- 演进0：纯脚本接口自动化测试
- 演进1：提炼接口自动化通用类
- 演进2：接口自动化通用类重构优化
- 演进3：支持RESTfull风格的接口
- 演进4：除了支持Http协议，新增支持陌生接口协议（例如WebSocket接口)
- 演进5：测试数据分离与参数化（参数类）

## 单接口的测试
单接口测试的重点，其实就是保证该接口的正确性和健壮性，也就是说，你既要保证这个接口可以按照需求，正确处理传入的参数，给出正确的返回；也可以按照需求，正确的拒绝传入非正确的参数，给出正确的拒绝性返回。

示例：登录接口
参数是 username 和 password，这两个参数均不可以为空，也不可以超过 10 个字符；如果 username 和 password 这两个字符串相同，会登录成功并返回后续的说明性文本，否则，就会正确拒绝登录。
使用边界值方法设计的参数如下：

|id|username|password|预期结果|
|---|---|---|---|
|1|devin|devin|正确进入系统，返回：please select One Equipment:\n10001:Knife\n10002:Big Sword\n10003:KuiHuaBaoDian|
|2|devin|null|正确拒绝进入系统|
|3|null|devin|正确拒绝进入系统|
|4|www.youmi.net|www.youmi.net|正确拒绝进入系统|

## 业务流程接口测试
业务流程接口测试，主要是保障通过多个接口的串联操作可以完成原来需求中提出的业务逻辑，这也是它主要关注的内容：“进入系统后，选择武器，然后和你选择的敌人决斗。”

依据上面这种业务逻辑描述，对其做进一步的分析和细化，我们可以得到至少有下面这几个业务流程：
- 正确登录系统后，选择武器，与敌人决斗，杀死了敌人；
- 正确登录系统后，选择武器，与敌人决斗，被敌人杀死；
- 正确登录系统后，选择武器，与敌人决斗，两个人同归于尽；
- 正确登录系统，选择武器，没有选择敌人，自尽而死；
- 正确登录系统，选择一个未提供的武器编号，选择一个敌人，自尽而死；
- 正确登录系统，选择武器，选择一个未出战的敌人（不在返回提示列表中），自尽而死。

针对以上业务流程，我们的用例参数如下：
|id|username|password|equipmentid|enemyid|预期结果|
|---|---|---|---|---|---|
|1|devin|devin|10003|20001|正常完成业务流，显示杀死敌人赢得比赛相关信息|
|2|devin|devin|10001|20002|正常完成业务流，显示被敌人杀死相关信息|
|3|devin|devin|10001|20001|正常完成业务流，显示与敌人同归于尽相关信息|
|4|devin|devin|10001|null|正常完成业务流，显示自杀而死相关信息|
|5|devin|devin|10008|20001|正常完成业务流，显示自杀而死相关信息|
|6|devin|devin|10001|20008|正常完成业务流，显示自杀而死相关信息|

通过观察上面的业务流测试，你会发现和单接口的测试用例相比，少了很多异常状况，比如正确登录、正拒绝登录、正确登陆选择的装备参数是字符串等等，这一系的业务流中的反向用例都没有进行验证。
这就是业务接口测试和单接口测试的差异点。在单接口测试中，我们会完全覆盖全部异常状态；而在业务流程中，我们更需要关心业务流和数据流的关系，并不需要再过度关心如何用业务流的方法覆盖更多的代码逻辑异常，这也是分层测试中为什么在单元测试和界面测试之间要加入一层接口测试的主要原因之一。通过单接口测试，可以更加接近于单元测试；通过业务流的接口测试，可以更加接近于界面所承载的交互中的业务流验证。


## 接口测试思维
综上，接口测试时，我们要先从单个接口的测试开始，保障单个接口的正确性和健壮性，然后通过单个接口的测试完成多个接口的业务逻辑串联，站在业务逻辑的角度完成业务逻辑的正确性检测。